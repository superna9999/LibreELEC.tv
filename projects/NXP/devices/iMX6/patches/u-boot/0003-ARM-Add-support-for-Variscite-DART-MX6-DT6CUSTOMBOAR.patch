From 42aa0d1f7aadce262c179f00b304374fd5cb95af Mon Sep 17 00:00:00 2001
From: Neil Armstrong <narmstrong@baylibre.com>
Date: Thu, 23 Nov 2017 15:39:59 +0100
Subject: [PATCH 3/3] ARM: Add support for Variscite DART-MX6+DT6CUSTOMBOARD

Signed-off-by: Neil Armstrong <narmstrong@baylibre.com>
---
 arch/arm/mach-imx/mx6/Kconfig                   |   9 +
 board/variscite/common/Makefile                 |  12 +
 board/variscite/common/dart-mx6.c               | 293 +++++++++++++++++
 board/variscite/common/dart-mx6.h               |  27 ++
 board/variscite/common/eeprom.c                 | 354 +++++++++++++++++++++
 board/variscite/common/eeprom_private.h         |  96 ++++++
 board/variscite/dt6customboard/Kconfig          |  12 +
 board/variscite/dt6customboard/MAINTAINERS      |   7 +
 board/variscite/dt6customboard/Makefile         |   8 +
 board/variscite/dt6customboard/README           |  21 ++
 board/variscite/dt6customboard/dt6customboard.c | 397 ++++++++++++++++++++++++
 configs/dt6customboard_defconfig                |  47 +++
 include/configs/dt6customboard.h                | 115 +++++++
 13 files changed, 1398 insertions(+)
 create mode 100644 board/variscite/common/Makefile
 create mode 100644 board/variscite/common/dart-mx6.c
 create mode 100644 board/variscite/common/dart-mx6.h
 create mode 100644 board/variscite/common/eeprom.c
 create mode 100644 board/variscite/common/eeprom_private.h
 create mode 100644 board/variscite/dt6customboard/Kconfig
 create mode 100644 board/variscite/dt6customboard/MAINTAINERS
 create mode 100644 board/variscite/dt6customboard/Makefile
 create mode 100644 board/variscite/dt6customboard/README
 create mode 100644 board/variscite/dt6customboard/dt6customboard.c
 create mode 100644 configs/dt6customboard_defconfig
 create mode 100644 include/configs/dt6customboard.h

diff --git a/arch/arm/mach-imx/mx6/Kconfig b/arch/arm/mach-imx/mx6/Kconfig
index 540f2b2..0ad343f 100644
--- a/arch/arm/mach-imx/mx6/Kconfig
+++ b/arch/arm/mach-imx/mx6/Kconfig
@@ -129,6 +129,14 @@ config TARGET_COLIBRI_IMX6
 	select DM_SERIAL
 	select DM_THERMAL
 
+config TARGET_DT6CUSTOMBOARD
+	bool "Variscite DART-MX6 Carrier-Board"
+	select BOARD_LATE_INIT
+	select SUPPORT_SPL
+	select DM
+	select DM_THERMAL
+	select BOARD_EARLY_INIT_F
+
 config TARGET_EMBESTMX6BOARDS
 	bool "embestmx6boards"
 	select BOARD_LATE_INIT
@@ -460,6 +468,7 @@ source "board/toradex/apalis_imx6/Kconfig"
 source "board/toradex/colibri_imx6/Kconfig"
 source "board/udoo/Kconfig"
 source "board/udoo/neo/Kconfig"
+source "board/variscite/dt6customboard/Kconfig"
 source "board/wandboard/Kconfig"
 source "board/warp/Kconfig"
 
diff --git a/board/variscite/common/Makefile b/board/variscite/common/Makefile
new file mode 100644
index 0000000..ff7d1ab
--- /dev/null
+++ b/board/variscite/common/Makefile
@@ -0,0 +1,12 @@
+#
+# (C) Copyright 2016 BayLibre, SAS
+# Author: Neil Armstrong <narmstrong@baylibre.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y  := dart-mx6.o eeprom.o
+else
+obj-y  := dart-mx6.o
+endif
diff --git a/board/variscite/common/dart-mx6.c b/board/variscite/common/dart-mx6.c
new file mode 100644
index 0000000..77ef499
--- /dev/null
+++ b/board/variscite/common/dart-mx6.c
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ *
+ * Copyright (C) 2016 Variscite Ltd. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <spl.h>
+#include <usb.h>
+#include <usb/ehci-ci.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "dart-mx6.h"
+
+#define RAM_SIZE_ADDR	((CONFIG_SPL_TEXT_BASE) + (CONFIG_SPL_MAX_SIZE))
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	IOMUX_PADS(PAD_CSI0_DAT10__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT11__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+};
+
+#ifdef CONFIG_SYS_I2C_MXC
+
+#define I2C_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+I2C_PADS(i2c2_pads,
+	PAD_KEY_COL3__I2C2_SCL | MUX_PAD_CTRL(I2C_PAD_CTRL),
+	PAD_KEY_COL3__GPIO4_IO12 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+	IMX_GPIO_NR(4, 12),
+	PAD_KEY_ROW3__I2C2_SDA | MUX_PAD_CTRL(I2C_PAD_CTRL),
+	PAD_KEY_ROW3__GPIO4_IO13 | MUX_PAD_CTRL(I2C_PAD_CTRL),
+	IMX_GPIO_NR(4, 13));
+#endif
+
+int dart_mx6_dram_init(void)
+{
+	u32 *p_ram_size = (u32 *)RAM_SIZE_ADDR;
+
+	gd->ram_size = *p_ram_size  * 1024 * 1024;
+
+	return 0;
+}
+
+int dart_mx6_eth_init(bd_t *bis)
+{
+	struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int ret = enable_fec_anatop_clock(0, ENET_25MHZ);
+	if (ret)
+		return ret;
+
+	/* set gpr1[ENET_CLK_SEL] */
+	setbits_le32(&iomuxc_regs->gpr[1], IOMUXC_GPR1_ENET_CLK_SEL_MASK);
+
+	return 0;
+}
+
+void dart_mx6_early_init_f(void)
+{
+	SETUP_IOMUX_PADS(uart1_pads);
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, I2C_PADS_INFO(i2c2_pads));
+#endif
+}
+
+int dart_mx6_board_init(void)
+{
+	int ret = 0;
+
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+
+	return ret;
+}
+
+struct pmic_write_values {
+	u32 reg;
+	u32 mask;
+	u32 writeval;
+};
+
+static int pmic_write_vals(struct pmic *dev,
+			   const struct pmic_write_values * const arr,
+			   int arr_size)
+{
+	unsigned int i, val;
+	int ret;
+
+	for (i = 0; i < arr_size; ++i) {
+		ret = pmic_reg_read(dev, arr[i].reg, &val);
+		if (ret)
+			return ret;
+		val &= ~(arr[i].mask);
+		val |= arr[i].writeval;
+		ret = pmic_reg_write(dev, arr[i].reg, val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct pmic_write_values pmic_arr[] = {
+	/* Set SW1AB standby volage to 0.9V */
+	{PFUZE100_SW1ABSTBY, SW1x_STBY_MASK, SW1x_0_900V},
+
+	/* Set SW1AB off volage to 0.9V */
+	{PFUZE100_SW1ABOFF, SW1x_OFF_MASK, SW1x_0_900V},
+
+	/* Set SW1C standby voltage to 0.9V */
+	{PFUZE100_SW1CSTBY, SW1x_STBY_MASK, SW1x_0_900V},
+
+	/* Set SW1C off volage to 0.9V */
+	{PFUZE100_SW1COFF, SW1x_OFF_MASK, SW1x_0_900V},
+
+	/* Set SW2 to 3.3V */
+	{PFUZE100_SW2VOL, SWx_NORMAL_MASK, SWx_HR_3_300V},
+
+	/* Set SW2 standby voltage to 3.2V */
+	{PFUZE100_SW2STBY, SWx_STBY_MASK, SWx_HR_3_200V},
+
+	/* Set SW2 off voltage to 3.2V */
+	{PFUZE100_SW2OFF, SWx_OFF_MASK, SWx_HR_3_200V},
+
+	/* Set SW1AB/VDDARM step ramp up time 2us */
+	{PFUZE100_SW1ABCONF, SW1xCONF_DVSSPEED_MASK, SW1xCONF_DVSSPEED_2US},
+
+	/* Set SW1AB, SW1C, SW2 normal mode to PWM, and standby mode to PFM */
+	{PFUZE100_SW1ABMODE, SW_MODE_MASK, PWM_PFM},
+	{PFUZE100_SW1CMODE, SW_MODE_MASK, PWM_PFM},
+	{PFUZE100_SW2MODE, SW_MODE_MASK, PWM_PFM},
+
+	/* Set VGEN6 to 3.3V */
+	{PFUZE100_VGEN6VOL, LDO_VOL_MASK, LDOB_3_30V},
+
+	/* Set SW1C/VDDSOC step ramp up time from 16us to 4us/25mV */
+	{PFUZE100_SW1CCONF, SW1xCONF_DVSSPEED_MASK, SW1xCONF_DVSSPEED_4US},
+};
+
+int power_init_board(void)
+{
+	struct pmic *dev;
+	unsigned int reg;
+	int ret;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	dev = pmic_get("PFUZE100");
+	ret = pmic_probe(dev);
+	if (ret)
+		return ret;
+
+	ret = pmic_reg_read(dev, PFUZE100_DEVICEID, &reg);
+	if (ret)
+		return ret;
+
+	printf("PMIC:  PFUZE100 ID=0x%02x\n", reg);
+
+	return pmic_write_vals(dev, pmic_arr, ARRAY_SIZE(pmic_arr));
+}
+
+int dart_mx6_late_init(void)
+{
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	if (is_mx6dq())
+		env_set("board_rev", "MX6Q");
+	else
+		env_set("board_rev", "MX6DL");
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_SPL_BUILD
+#include <asm/arch/mx6-ddr.h>
+
+#define PER_VCC_EN_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |	\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+
+static iomux_v3_cfg_t const per_vcc_en_pads[] = {
+	IOMUX_PADS(PAD_EIM_D31__GPIO3_IO31 | MUX_PAD_CTRL(PER_VCC_EN_PAD_CTRL)),
+};
+
+#define PER_VCC_EN	IMX_GPIO_NR(3, 31)
+
+static iomux_v3_cfg_t const audio_reset_pads[] = {
+	IOMUX_PADS(PAD_GPIO_19__GPIO4_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+#define AUDIO_RESET	IMX_GPIO_NR(4, 5)
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0x00C03F3F, &ccm->CCGR0);
+	writel(0x0030FC03, &ccm->CCGR1);
+	writel(0x0FFFC000, &ccm->CCGR2);
+	writel(0x3FF00000, &ccm->CCGR3);
+	writel(0x00FFF300, &ccm->CCGR4);
+	writel(0x0F0000C3, &ccm->CCGR5);
+	writel(0x000003FF, &ccm->CCGR6);
+}
+
+/*
+ * Bugfix: Fix Freescale wrong processor documentation.
+ */
+static void spl_mx6qd_dram_setup_iomux_check_reset(void)
+{
+	volatile struct mx6dq_iomux_ddr_regs *mx6dq_ddr_iomux;
+
+	mx6dq_ddr_iomux = (struct mx6dq_iomux_ddr_regs *) MX6DQ_IOM_DDR_BASE;
+
+	if (mx6dq_ddr_iomux->dram_reset == (u32)0x000C0030)
+		mx6dq_ddr_iomux->dram_reset = (u32)0x00000030;
+}
+
+static void spl_dram_init(void)
+{
+	u32 *p_ram_size = (u32 *)RAM_SIZE_ADDR;
+	*p_ram_size = dart_mx6_eeprom_dram_init();
+
+	spl_mx6qd_dram_setup_iomux_check_reset();
+}
+
+void dart_mx6_init_f(ulong dummy)
+{
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	ccgr_init();
+	gpr_init();
+
+	/* Enable peripherals power */
+	SETUP_IOMUX_PADS(per_vcc_en_pads);
+	gpio_direction_output(PER_VCC_EN, 1);
+
+	/* Reset Audio Codec */
+	SETUP_IOMUX_PADS(audio_reset_pads);
+	gpio_direction_output(AUDIO_RESET, 0);
+
+	/* iomux and setup of i2c */
+	board_early_init_f();
+
+	/* setup GP timer */
+	timer_init();
+
+	mdelay(300);
+
+	/* UNReset Audio Codec */
+	gpio_direction_output(AUDIO_RESET, 1);
+
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	/* load/boot image from boot device */
+	board_init_r(NULL, 0);
+}
+#endif
diff --git a/board/variscite/common/dart-mx6.h b/board/variscite/common/dart-mx6.h
new file mode 100644
index 0000000..c091d54
--- /dev/null
+++ b/board/variscite/common/dart-mx6.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef COMMON_DART_MX6_H
+#define COMMON_DART_MX6_H
+
+int dart_mx6_dram_init(void);
+
+int dart_mx6_eth_init(bd_t *bis);
+
+void dart_mx6_early_init_f(void);
+
+int dart_mx6_board_init(void);
+
+int dart_mx6_late_init(void);
+
+#ifdef CONFIG_SPL_BUILD
+int dart_mx6_eeprom_dram_init(void);
+
+void dart_mx6_init_f(ulong dummy);
+#endif
+
+#endif
diff --git a/board/variscite/common/eeprom.c b/board/variscite/common/eeprom.c
new file mode 100644
index 0000000..5423d6e
--- /dev/null
+++ b/board/variscite/common/eeprom.c
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ *
+ * Copyright (C) 2016 Variscite Ltd. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include "eeprom_private.h"
+
+#define VARISCITE_MAGIC_V2		0x32524156 /* == HEX("VAR2") */
+
+#define VAR_DART_EEPROM_I2C_BUS		0
+#define VAR_DART_EEPROM_I2C_ADDR	0x52
+
+#define WHILE_NOT_EQUAL_INDEX		241
+#define WHILE_EQUAL_INDEX		242
+#define WHILE_AND_INDEX			243
+#define WHILE_NOT_AND_INDEX		244
+#define DELAY_10USEC_INDEX		245
+#define LAST_COMMAND_INDEX		255
+
+#define MAX_CUSTOM_ADDRESSES		32
+#define MAX_CUSTOM_VALUES		32
+
+#define MAX_COMMON_ADDRS_INDEX		200
+#define MAX_COMMON_VALUES_INDEX		200
+
+#define MAX_NUM_OF_COMMANDS		150
+
+struct __attribute__((packed)) eeprom_command
+{
+	u8 address_index;
+	u8 value_index;
+};
+
+struct __attribute__((packed)) eeprom_cfg
+{
+	u32 variscite_magic; /* == HEX("VAR2")? */
+	u8 part_number[16];
+	u8 Assembly[16];
+	u8 date[12];
+
+	/* Contains addresses and values not present in .inc files */
+	u32 custom_addresses_values[32];
+	struct eeprom_command commands[MAX_NUM_OF_COMMANDS];
+	u8 reserved[34];
+
+	/* DRAM size in 8KiB unit */
+	u8 dram_size;
+	u8 crc;
+};
+
+static int dart_mx6_eeprom_read_struct(struct eeprom_cfg *eeprom_cfg)
+{
+	i2c_set_bus_num(VAR_DART_EEPROM_I2C_BUS);
+
+	if (i2c_probe(VAR_DART_EEPROM_I2C_ADDR)) {
+		printf("Error: Couldn't find EEPROM device\n");
+		return -1;
+	}
+
+	if (i2c_read(VAR_DART_EEPROM_I2C_ADDR, 0, 1,
+				(u8 *) eeprom_cfg,
+				sizeof(struct eeprom_cfg))) {
+		printf("Error reading data from EEPROM\n");
+		return -1;
+	}
+
+	if (VARISCITE_MAGIC_V2 != eeprom_cfg->variscite_magic) {
+		printf("Error: Data on EEPROM is invalid\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Fills custom_addresses & custom_values, from custom_addresses_values
+ */
+static void dart_mx6_load_custom_data(u32 *custom_addresses,
+				      u32 *custom_values,
+				      const u32 *custom_addresses_values)
+{
+	int i, j;
+
+	for (i = 0; i < MAX_CUSTOM_ADDRESSES; i++) {
+		if (custom_addresses_values[i] == 0)
+			break;
+		custom_addresses[i] = custom_addresses_values[i];
+	}
+
+	i++;
+	if (i > MAX_CUSTOM_ADDRESSES)
+		return;
+
+	j = 0;
+	for (; i < MAX_CUSTOM_VALUES; i++) {
+		if (custom_addresses_values[i] == 0)
+			break;
+		custom_values[j] = custom_addresses_values[i];
+		j++;
+	}
+}
+
+static u32 dart_mx6_get_address_by_index(u8 index,
+					 const u32 *common_addresses,
+					 const u32 *custom_addresses)
+{
+	if (index >= MAX_COMMON_ADDRS_INDEX)
+		return custom_addresses[index - MAX_COMMON_ADDRS_INDEX];
+
+	return common_addresses[index];
+}
+
+static u32 dart_mx6_get_value_by_index(u8 index,
+				       const u32 *common_values,
+				       const u32 *custom_values)
+{
+	if (index >= MAX_COMMON_VALUES_INDEX)
+		return custom_values[index - MAX_COMMON_VALUES_INDEX];
+
+	return common_values[index];
+}
+
+static int dart_mx6_handle_commands(const struct eeprom_command commands[],
+				    const u32 *common_addresses,
+				    const u32 *common_values,
+				    const u32 *custom_addresses,
+				    const u32 *custom_values)
+{
+	u32 address, value;
+	volatile u32 *reg_ptr;
+	u8 wait_idx = 0;
+	int i = 0;
+
+	while (i < MAX_NUM_OF_COMMANDS) {
+		if (commands[i].address_index == LAST_COMMAND_INDEX)
+			return 0;
+
+		if (commands[i].address_index == DELAY_10USEC_INDEX) {
+			/* Delay for Value * 10 uSeconds */
+			udelay((int)(commands[i].value_index * 10));
+			++i;
+			continue;
+		}
+
+		/*
+		 * Check for a wait index.
+		 * A wait index means "next command is a wait command".
+		 */
+		switch (commands[i].address_index) {
+		case WHILE_NOT_EQUAL_INDEX:
+		case WHILE_EQUAL_INDEX:
+		case WHILE_AND_INDEX:
+		case WHILE_NOT_AND_INDEX:
+			/* Save wait index and go to next command */
+			wait_idx = commands[i].address_index;
+			++i;
+			break;
+		}
+
+		/* Get address and value */
+		address = dart_mx6_get_address_by_index(
+				commands[i].address_index,
+				common_addresses,
+				custom_addresses);
+		value = dart_mx6_get_value_by_index(
+				commands[i].value_index,
+				common_values,
+				custom_values);
+		reg_ptr = (u32 *)address;
+
+		switch (wait_idx) {
+		case WHILE_NOT_EQUAL_INDEX:
+			/* Waiting while data at address is not equal */
+			while(*reg_ptr != value);
+			break;
+		case WHILE_EQUAL_INDEX:
+			/* Waiting while data at address is equal */
+			while(*reg_ptr == value);
+			break;
+		case WHILE_AND_INDEX:
+			/* Waiting while data at address is not zero */
+			while(*reg_ptr & value);
+			break;
+		case WHILE_NOT_AND_INDEX:
+			/* Waiting while data at address is zero */
+			while(!(*reg_ptr & value));
+			break;
+		default:
+			/* This is a regular set command (non-wait) */
+			*reg_ptr = value;
+			break;
+		}
+
+		++i;
+	}
+
+	return 0;
+}
+
+/*
+ * This is an automatically generated part.
+ */
+static unsigned char MX6Q_MMDC_LPDDR2_register_programming_aid_v0_Micron_InterL_commands[]={
+	0x01, 0x9B,	0x02, 0x9B,	0x03, 0x9B,	0x04, 0x9B,
+	0x05, 0x9B,	0x06, 0x9B,	0x07, 0x9B,	0x42, 0x1C,
+	0x3D, 0x00,	0x2C, 0x07,	0x2E, 0x07,	0x29, 0x07,
+	0x2A, 0x07,	0x2B, 0x07,	0x2D, 0x00,	0x2F, 0x07,
+	0x30, 0x07,	0x3A, 0x07,	0x48, 0x07,	0x3B, 0x1C,
+	0x31, 0x13,	0x33, 0x13,	0x27, 0x13,	0x25, 0x13,
+	0x24, 0x13,	0x21, 0x13,	0x35, 0x13,	0x37, 0x13,
+	0x4A, 0x26,	0x46, 0x07,	0x47, 0x07,	0x49, 0x07,
+	0x4B, 0x07,	0x4C, 0x07,	0x4D, 0x07,	0x4E, 0x07,
+	0x39, 0x07,	0x32, 0x07,	0x34, 0x07,	0x28, 0x07,
+	0x26, 0x07,	0x23, 0x07,	0x22, 0x07,	0x36, 0x07,
+	0x38, 0x07,	0xC8, 0xC8,	0xC9, 0xC9,	0x56, 0x16,
+	0x79, 0x16,	0x6E, 0x66,	0x91, 0x66,	0x5E, 0x90,
+	0x81, 0x90,	0x6F, 0x3A,	0x92, 0x3A,	0x62, 0x6C,
+	0x63, 0xCA,	0x64, 0x6C,	0x65, 0x6C,	0x85, 0x6C,
+	0x86, 0x6C,	0x87, 0x6C,	0x88, 0x6C,	0x66, 0x97,
+	0x67, 0xCA,	0x68, 0x97,	0x69, 0x97,	0x89, 0x97,
+	0x8A, 0x97,	0x8B, 0x97,	0x8C, 0x97,	0x70, 0x0D,
+	0x93, 0x0D,	0x6C, 0xCB,	0x8F, 0xCC,	0x6D, 0xCD,
+	0x90, 0xCE,	0x6A, 0x67,	0x6B, 0x00,	0x8D, 0x67,
+	0x8E, 0x00,	0x71, 0x69,	0x95, 0x69,	0x52, 0xCF,
+	0x50, 0x1F,	0x53, 0xD0,	0x54, 0xD1,	0x55, 0x0F,
+	0x58, 0xD2,	0x59, 0xD3,	0x5A, 0xD4,	0x51, 0x00,
+	0x5B, 0x09,	0x5C, 0x61,	0x4F, 0x8B,	0x75, 0xCF,
+	0x73, 0x1F,	0x76, 0xD0,	0x77, 0xD1,	0x78, 0x0F,
+	0x7B, 0xD2,	0x7C, 0xD3,	0x7D, 0xD4,	0x74, 0x00,
+	0x7E, 0x02,	0x7F, 0x61,	0x72, 0x8B,	0x56, 0x38,
+	0x56, 0x98,	0x56, 0x93,	0x56, 0x5B,	0x56, 0x45,
+	0x79, 0x38,	0x79, 0x98,	0x79, 0x93,	0x79, 0x5B,
+	0x79, 0x45,	0x5E, 0x90,	0x57, 0xD5,	0x7A, 0xD5,
+	0x61, 0x00,	0x84, 0x00,	0x50, 0x23,	0x73, 0x23,
+	0x5D, 0x19,	0x80, 0x19,	0x56, 0x00,	0x79, 0x00,
+	0xFF, 0xFF
+};
+/* End of automatically generated part */
+
+/*
+ * This is an automatically generated part.
+ * Address file was: addresses.inc
+ * Address file MD5 was: 980A738D4534913CD453034EBE23D4EA
+ * Values file was: values.inc
+ * Values file MD5 was: 21A75C9EDCB34288E2E75596CF8430F6
+ * DDR file was: mt128x64mx32_Step3.inc
+ * DDR file MD5 was: E095B4E8E969E41800AF5A6E104D650C
+ */
+static unsigned char mt128x64mx32_Step3_commands[]={
+	0xC8, 0xC8,	0xC9, 0xC9,	0x01, 0x9B,	0x02, 0x9B,
+	0x03, 0x9B,	0x04, 0x9B,	0x05, 0x9B,	0x06, 0x9B,
+	0x07, 0x9B,	0x08, 0x9B,	0x42, 0x1C,	0x3D, 0x00,
+	0x2C, 0x06,	0x2E, 0x06,	0x29, 0x06,	0x2A, 0x06,
+	0x2B, 0x06,	0x2D, 0x00,	0x2F, 0x06,	0x30, 0x06,
+	0x3A, 0x06,	0x48, 0x06,	0x3B, 0x1C,	0x31, 0x13,
+	0x33, 0x13,	0x27, 0x13,	0x25, 0x13,	0x24, 0x13,
+	0x21, 0x13,	0x35, 0x13,	0x37, 0x13,	0x4A, 0x26,
+	0x46, 0x06,	0x47, 0x06,	0x49, 0x06,	0x4B, 0x06,
+	0x4C, 0x06,	0x4D, 0x06,	0x4E, 0x06,	0x39, 0x06,
+	0x32, 0x06,	0x34, 0x06,	0x28, 0x06,	0x26, 0x06,
+	0x23, 0x06,	0x22, 0x06,	0x36, 0x06,	0x38, 0x06,
+	0x56, 0x16,	0x79, 0x16,	0x6E, 0xCA,	0x91, 0xCA,
+	0x5E, 0x90,	0x81, 0xCB,	0x6F, 0x3A,	0x92, 0x3A,
+	0x70, 0x0D,	0x93, 0x0D,	0x62, 0x6C,	0x63, 0x6C,
+	0x64, 0x6C,	0x65, 0x6C,	0x85, 0x6C,	0x86, 0x6C,
+	0x87, 0x6C,	0x88, 0x6C,	0x66, 0x97,	0x67, 0x97,
+	0x68, 0x97,	0x69, 0x97,	0x89, 0x97,	0x8A, 0x97,
+	0x8B, 0x97,	0x8C, 0x97,	0x6C, 0xCC,	0x8F, 0xCD,
+	0x6D, 0xCE,	0x90, 0xCF,	0x6A, 0x67,	0x6B, 0x00,
+	0x8D, 0x67,	0x8E, 0x00,	0x71, 0x69,	0x95, 0x69,
+	0x70, 0x0D,	0x93, 0x0D,	0x52, 0xD0,	0x50, 0x1F,
+	0x53, 0xD1,	0x54, 0xD2,	0x55, 0x0F,	0x58, 0x60,
+	0x59, 0xD3,	0x5A, 0xD4,	0x51, 0x00,	0x5B, 0x09,
+	0x4F, 0x8B,	0x75, 0xD0,	0x73, 0x1F,	0x76, 0xD1,
+	0x77, 0xD2,	0x78, 0x0F,	0x7B, 0x60,	0x7C, 0xD3,
+	0x7D, 0xD4,	0x74, 0x00,	0x7E, 0x02,	0x72, 0x8B,
+	0x56, 0x38,	0x56, 0x98,	0x56, 0x93,	0x56, 0xD5,
+	0x56, 0xD6,	0x79, 0x38,	0x79, 0x98,	0x79, 0x93,
+	0x79, 0xD5,	0x79, 0xD6,	0x57, 0x10,	0x7A, 0x10,
+	0x61, 0x00,	0x84, 0x00,	0x70, 0x0D,	0x93, 0x0D,
+	0x50, 0x23,	0x73, 0x23,	0x5D, 0x19,	0x80, 0x19,
+	0x56, 0x00,	0x79, 0x00,	0xCA, 0xD7,	0xCB, 0xD8,
+	0xCC, 0xD8,	0xFF, 0xFF
+};
+
+static u32 mt128x64mx32_Step3_RamValues[]={
+	/* ADDRESSES */
+	0x020C4018, 0x020C4014, 0x020E0010, 0x020E0018,
+	0x020E001C, 0x00000000,
+	/* VALUES */
+	0x00060324, 0x00018900, 0x1B5F0109, 0xA1310003,
+	0x40404046, 0x42424648, 0x3A383C34, 0x40323C3C,
+	0x33374133, 0x00100A82, 0x00000093, 0x009F0E10,
+	0x001A0889, 0x04028030, 0x03038030, 0xF00000CF,
+	0x007F007F, 0x00000000
+};
+/* End of automatically generated part */
+
+int dart_mx6_eeprom_dram_init(void)
+{
+	struct eeprom_cfg eeprom_cfg = {0};
+	int is_eeprom_valid = !(dart_mx6_eeprom_read_struct(&eeprom_cfg));
+	int is_eeprom_data_correct = is_eeprom_valid;
+
+	/*
+	 * The eeprom contains commands with
+	 * 1 byte index to a common address in this array, and
+	 * 1 byte index to a common value in the next array - to write to the address.
+	 * Some commands in the eeprom contain higher indices,
+	 * to custom addresses and values which are not present in the common arrays,
+	 * and it also contains an array of the custom addresses and values themselves.
+	 */
+	u32 custom_addresses[MAX_CUSTOM_ADDRESSES] = {0};
+	u32 custom_values[MAX_CUSTOM_VALUES] = {0};
+
+	/*
+	 * The MX6Q_MMDC_LPDDR2_register_programming_aid_v0_Micron_InterL_commands
+	 * revision is incorrect.
+	 * If the data is equal to it, use mt128x64mx32_Step3_commands revision instead
+	 */
+	if (is_eeprom_valid &&
+	    !memcmp(eeprom_cfg.commands,
+		    MX6Q_MMDC_LPDDR2_register_programming_aid_v0_Micron_InterL_commands,
+		    254))
+		is_eeprom_data_correct = 0;
+
+	dart_mx6_load_custom_data(custom_addresses, custom_values,
+			is_eeprom_data_correct ?
+			eeprom_cfg.custom_addresses_values:
+			mt128x64mx32_Step3_RamValues);
+
+	dart_mx6_handle_commands(is_eeprom_data_correct ?
+				 eeprom_cfg.commands :
+				 (struct eeprom_command *)
+				 	mt128x64mx32_Step3_commands,
+				 common_addresses,
+				 common_values,
+				 custom_addresses,
+				 custom_values);
+
+	if (is_eeprom_valid) {
+		return eeprom_cfg.dram_size * 128;
+	} else {
+		printf("DDR LEGACY configuration\n");
+
+		return 1024;
+	}
+}
diff --git a/board/variscite/common/eeprom_private.h b/board/variscite/common/eeprom_private.h
new file mode 100644
index 0000000..bacdcb3
--- /dev/null
+++ b/board/variscite/common/eeprom_private.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ *
+ * Copyright (C) 2016 Variscite Ltd. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef COMMON_DART_MX6_EEPROM_H
+#define COMMON_DART_MX6_EEPROM_H
+
+static u32 common_addresses[] = {
+	0x00000000, 0x020C4068, 0x020C406C, 0x020C4070,
+	0x020C4074, 0x020C4078, 0x020C407C, 0x020C4080,
+	0x020C4084, 0x020E0464, 0x020E0470, 0x020E0474,
+	0x020E0478, 0x020E047C, 0x020E0480, 0x020E0484,
+	0x020E0488, 0x020E048C, 0x020E0490, 0x020E0494,
+	0x020E04A0, 0x020E04AC, 0x020E04B0, 0x020E04B4,
+	0x020E04B8, 0x020E04BC, 0x020E04C0, 0x020E04C4,
+	0x020E04C8, 0x020E04CC, 0x020E04D0, 0x020E04D4,
+	0x020E04D8, 0x020E050C, 0x020E0510, 0x020E0514,
+	0x020E0518, 0x020E051C, 0x020E0520, 0x020E0524,
+	0x020E0528, 0x020E056C, 0x020E0578, 0x020E057C,
+	0x020E0588, 0x020E058C, 0x020E0594, 0x020E059C,
+	0x020E05A0, 0x020E05A8, 0x020E05AC, 0x020E05B0,
+	0x020E05B4, 0x020E05B8, 0x020E05BC, 0x020E05C0,
+	0x020E05C4, 0x020E0748, 0x020E074C, 0x020E0750,
+	0x020E0754, 0x020E0758, 0x020E0760, 0x020E0764,
+	0x020E076C, 0x020E0770, 0x020E0774, 0x020E0778,
+	0x020E077C, 0x020E0780, 0x020E0784, 0x020E0788,
+	0x020E078C, 0x020E0794, 0x020E0798, 0x020E079C,
+	0x020E07A0, 0x020E07A4, 0x020E07A8, 0x021B0000,
+	0x021B0004, 0x021B0008, 0x021B000C, 0x021B0010,
+	0x021B0014, 0x021B0018, 0x021B001C, 0x021B0020,
+	0x021B002C, 0x021B0030, 0x021B0038, 0x021B0040,
+	0x021B0400, 0x021B0404, 0x021B0800, 0x021B080C,
+	0x021B0810, 0x021B0818, 0x021B081C, 0x021B0820,
+	0x021B0824, 0x021B0828, 0x021B082C, 0x021B0830,
+	0x021B0834, 0x021B0838, 0x021B083C, 0x021B0840,
+	0x021B0848, 0x021B0850, 0x021B085C, 0x021B0890,
+	0x021B08B8, 0x021B08C0, 0x021B4000, 0x021B4004,
+	0x021B4008, 0x021B400C, 0x021B4010, 0x021B4014,
+	0x021B4018, 0x021B401C, 0x021B4020, 0x021B402C,
+	0x021B4030, 0x021B4038, 0x021B4040, 0x021B4400,
+	0x021B4404, 0x021B4800, 0x021B480C, 0x021B4810,
+	0x021B4818, 0x021B481C, 0x021B4820, 0x021B4824,
+	0x021B4828, 0x021B482C, 0x021B4830, 0x021B4834,
+	0x021B4838, 0x021B483C, 0x021B4840, 0x021B4848,
+	0x021B4850, 0x021B485C, 0x021B4890, 0x021B48B8,
+	0x021B48BC, 0x021B48C0
+};
+
+static const u32 common_values[] = {
+	0x00000000,0x00000010,0x00000013,0x00000017,
+	0x00000027,0x00000028,0x00000030,0x00000038,
+	0x00000047,0x00000053,0x00000080,0x000000DD,
+	0x0000020E,0x00000800,0x00001740,0x0000174C,
+	0x00001800,0x000026D2,0x00003000,0x00003030,
+	0x00005800,0x00007800,0x00008000,0x00008033,
+	0x0000803B,0x00011006,0x00011117,0x00011740,
+	0x00020000,0x00020025,0x0002002D,0x00020036,
+	0x00022227,0x00025565,0x0002556D,0x00025576,
+	0x00048031,0x00048039,0x00080000,0x00081740,
+	0x000C0000,0x000C0030,0x00130029,0x00160E83,
+	0x0019002E,0x001C0019,0x001D002C,0x001F0019,
+	0x001F001F,0x001F002B,0x00220AAC,0x0024001F,
+	0x00260026,0x00333030,0x00333040,0x003F1023,
+	0x003F8030,0x003F8038,0x00400000,0x00431023,
+	0x00450000,0x005A1023,0x006B1023,0x008E1023,
+	0x008F1023,0x017B017A,0x01FF00DB,0x02008032,
+	0x0200803A,0x02038030,0x02088032,0x0208803A,
+	0x0214021C,0x021B08B8,0x02280228,0x02300238,
+	0x02580258,0x03038038,0x03200314,0x032C0278,
+	0x033C0350,0x04008032,0x0400803A,0x04008040,
+	0x04008048,0x04088032,0x0408803A,0x05208030,
+	0x05208038,0x052C0470,0x052C0520,0x06028030,
+	0x06028038,0x07208030,0x09408030,0x09444040,
+	0x0F9F26D2,0x11420000,0x15208030,0x15208038,
+	0x19408030,0x19408038,0x1B5F01FF,0x20000000,
+	0x24911492,0x24921492,0x2B35382B,0x3234342C,
+	0x33333333,0x38362E32,0x38363236,0x38383E3A,
+	0x3A363446,0x3A38443C,0x3A3F7975,0x3E363A40,
+	0x3E373A3C,0x3E463E40,0x3F435313,0x4036363A,
+	0x403C3246,0x40404040,0x421C0216,0x421C0228,
+	0x423D3843,0x42440244,0x43240334,0x432C0340,
+	0x4528053C,0x45300544,0x454A61A5,0x46344840,
+	0x48364A3E,0x484A4C4A,0x4B2B4842,0x4B4A4E4C,
+	0x555A7974,0x676B5313,0x821A0000,0x83110000,
+	0x831A0000,0x84190000,0x841A0000,0x8A8F7955,
+	0xA1390003,0xB66D8B63,0xB66E8B63,0xC2018030,
+	0xC2018038,0xC41A0000,0xDB538F64,0xF3333333,
+	0xFF0A8030,0xFF0A8038,0xFF328F64,0xFFFFFFFF
+};
+
+#endif
diff --git a/board/variscite/dt6customboard/Kconfig b/board/variscite/dt6customboard/Kconfig
new file mode 100644
index 0000000..7134177
--- /dev/null
+++ b/board/variscite/dt6customboard/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_DT6CUSTOMBOARD
+
+config SYS_BOARD
+	default "dt6customboard"
+
+config SYS_VENDOR
+	default "variscite"
+
+config SYS_CONFIG_NAME
+	default "dt6customboard"
+
+endif
diff --git a/board/variscite/dt6customboard/MAINTAINERS b/board/variscite/dt6customboard/MAINTAINERS
new file mode 100644
index 0000000..1965928
--- /dev/null
+++ b/board/variscite/dt6customboard/MAINTAINERS
@@ -0,0 +1,7 @@
+DT6CUSTOMBOARD BOARD
+M:	Neil Armstrong <narmstrong@baylibre.com>
+S:	Maintained
+F:	board/variscite/dt6customboard/
+F:	board/variscite/common/
+F:	include/configs/dt6customboard.h
+F:	configs/dt6customboard_defconfig
diff --git a/board/variscite/dt6customboard/Makefile b/board/variscite/dt6customboard/Makefile
new file mode 100644
index 0000000..a4ab0bf
--- /dev/null
+++ b/board/variscite/dt6customboard/Makefile
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2016 BayLibre, SAS
+# Author: Neil Armstrong <narmstrong@baylibre.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := dt6customboard.o
diff --git a/board/variscite/dt6customboard/README b/board/variscite/dt6customboard/README
new file mode 100644
index 0000000..d380aec
--- /dev/null
+++ b/board/variscite/dt6customboard/README
@@ -0,0 +1,21 @@
+How to use U-Boot on Variscite DT6CUSTOMBOARD with DART-MX6 SoM
+----------------------------------------------------------------
+
+- Build U-Boot for DT6CUSTOMBOARD :
+
+$ make mrproper
+$ make dt6customboard_defconfig
+$ make
+
+This will generate the SPL image called SPL and the u-boot.img.
+
+- Flash the SPL image into the SD card:
+
+sudo dd if=SPL of=/dev/mmcblk0 bs=1k seek=1; sync
+
+- Flash the u-boot.img image into the SD card:
+
+sudo dd if=u-boot.img of=/dev/mmcblk0 bs=1k seek=69; sync
+
+- Insert the SD card in the board, power it up and U-Boot messages should
+come up.
diff --git a/board/variscite/dt6customboard/dt6customboard.c b/board/variscite/dt6customboard/dt6customboard.c
new file mode 100644
index 0000000..de56618
--- /dev/null
+++ b/board/variscite/dt6customboard/dt6customboard.c
@@ -0,0 +1,397 @@
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <micrel.h>
+#include <netdev.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <spl.h>
+#include <usb.h>
+#include <usb/ehci-ci.h>
+#include "../common/dart-mx6.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	IOMUX_PADS(PAD_SD2_CLK__SD2_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_CMD__SD2_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_DAT0__SD2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_DAT1__SD2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_DAT2__SD2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_DAT3__SD2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	/* Card Detect */
+	IOMUX_PADS(PAD_GPIO_6__GPIO1_IO06 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+#define USDHC2_CD	IMX_GPIO_NR(1, 6)
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	IOMUX_PADS(PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_CMD__SD3_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const usb_pads[] = {
+	IOMUX_PADS(PAD_ENET_RX_ER__USB_OTG_ID	| MUX_PAD_CTRL(OTG_ID_PAD_CTRL)),
+	IOMUX_PADS(PAD_KEY_ROW4__GPIO4_IO15	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_TX_EN__GPIO1_IO28	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+#define USB_OTG_VBUS	IMX_GPIO_NR(4, 15)
+#define USB_H1_VBUS	IMX_GPIO_NR(1, 28)
+
+static iomux_v3_cfg_t const enet_pads[] = {
+	IOMUX_PADS(PAD_ENET_MDIO__ENET_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_MDC__ENET_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TXC__RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD0__RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD1__RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD2__RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD3__RGMII_TD3 | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TX_CTL__RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_REF_CLK__ENET_TX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const enet_rx_pads_reset[] = {
+	/* pin 35 - 1 (PHY_AD2) on reset */
+	IOMUX_PADS(PAD_RGMII_RXC__GPIO6_IO30		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 32 - 1 - (MODE0) all */
+	IOMUX_PADS(PAD_RGMII_RD0__GPIO6_IO25		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 31 - 1 - (MODE1) all */
+	IOMUX_PADS(PAD_RGMII_RD1__GPIO6_IO27		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 28 - 1 - (MODE2) all */
+	IOMUX_PADS(PAD_RGMII_RD2__GPIO6_IO28		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 27 - 1 - (MODE3) all */
+	IOMUX_PADS(PAD_RGMII_RD3__GPIO6_IO29		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	/* pin 33 - 1 - (CLK125_EN) 125Mhz clockout enabled */
+	IOMUX_PADS(PAD_RGMII_RX_CTL__GPIO6_IO24		| MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const enet_rx_pads[] = {
+	IOMUX_PADS(PAD_RGMII_RXC__RGMII_RXC		| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD0__RGMII_RD0		| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD1__RGMII_RD1		| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD2__RGMII_RD2		| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD3__RGMII_RD3		| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const enet_phy_pads[] = {
+	/* PHY Reset */
+	IOMUX_PADS(PAD_ENET_CRS_DV__GPIO1_IO25 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+#define ETH_PHY_RESET	IMX_GPIO_NR(1, 25)
+
+static iomux_v3_cfg_t const backlight_pads[] = {
+	IOMUX_PADS(PAD_DISP0_DAT9__GPIO4_IO30 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+#define BACKLIGHT_EN	IMX_GPIO_NR(4, 30)
+
+int dram_init(void)
+{
+	return dart_mx6_dram_init();
+}
+
+struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC2_BASE_ADDR},
+	{USDHC3_BASE_ADDR},
+};
+
+int board_mmc_get_env_dev(int devno)
+{
+	return devno - 1;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = 1; /* eMMC/uSDHC3 is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+#ifndef CONFIG_SPL_BUILD
+	int ret;
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    SD2
+	 * mmc1                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			SETUP_IOMUX_PADS(usdhc2_pads);
+			gpio_direction_input(USDHC2_CD);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+			SETUP_IOMUX_PADS(usdhc3_pads);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+			       "(%d) then supported by the board (%d)\n",
+			       i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+#else
+	struct src *psrc = (struct src *)SRC_BASE_ADDR;
+	unsigned reg = readl(&psrc->sbmr1) >> 11;
+	/*
+	 * Upon reading BOOT_CFG register the following map is done:
+	 * Bit 11 and 12 of BOOT_CFG register can determine the current
+	 * mmc port
+	 * 0x1                  SD
+	 * 0x2                  eMMC
+	 */
+
+	switch (reg & 0x3) {
+	case 0x1:
+		SETUP_IOMUX_PADS(usdhc2_pads);
+		usdhc_cfg[0].esdhc_base = USDHC2_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+		gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+		break;
+	case 0x2:
+		SETUP_IOMUX_PADS(usdhc3_pads);
+		usdhc_cfg[0].esdhc_base = USDHC3_BASE_ADDR;
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+		gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+		break;
+	}
+
+	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+#endif
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x9, 0x1c00);
+
+	/* control data pad skew */
+	ksz9031_phy_extended_write(phydev, 0x02,
+			MII_KSZ9031_EXT_RGMII_CTRL_SIG_SKEW,
+			MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x0000);
+	/* rx data pad skew */
+	ksz9031_phy_extended_write(phydev, 0x02,
+			MII_KSZ9031_EXT_RGMII_RX_DATA_SKEW,
+			MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x0000);
+	/* tx data pad skew */
+	ksz9031_phy_extended_write(phydev, 0x02,
+			MII_KSZ9031_EXT_RGMII_TX_DATA_SKEW,
+			MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x0000);
+	/* gtx and rx clock pad skew */
+	ksz9031_phy_extended_write(phydev, 0x02,
+			MII_KSZ9031_EXT_RGMII_CLOCK_SKEW,
+			MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x03FF);
+
+	return 0;
+}
+
+#define ETH_PHY_MASK	(1 << CONFIG_FEC_MXC_PHYADDR)
+
+/* Micrel PHY Reset Sequence */
+static void enet_reset(void)
+{
+	SETUP_IOMUX_PADS(enet_phy_pads);
+
+	gpio_direction_output(ETH_PHY_RESET, 0);
+
+	gpio_direction_output(IMX_GPIO_NR(6, 30), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 25), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 27), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 28), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 29), 1);
+
+	SETUP_IOMUX_PADS(enet_pads);
+	SETUP_IOMUX_PADS(enet_rx_pads_reset);
+
+	gpio_direction_output(IMX_GPIO_NR(6, 24), 1);
+
+	mdelay(10);
+
+	/* Reset PHY */
+	gpio_set_value(ETH_PHY_RESET, 1);
+
+	SETUP_IOMUX_PADS(enet_rx_pads);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	struct mii_dev *bus;
+	struct phy_device *phydev;
+	int ret;
+
+	ret = dart_mx6_eth_init(bis);
+	if (ret)
+		return ret;
+
+	enet_reset();
+
+	bus = fec_get_miibus(IMX_FEC_BASE, -1);
+	if (!bus)
+		return -EINVAL;
+
+	phydev = phy_find_by_mask(bus, ETH_PHY_MASK, PHY_INTERFACE_MODE_RGMII);
+	if (!phydev) {
+		ret = -EINVAL;
+		goto free_bus;
+	}
+
+	mdelay(10);
+
+	printf("using phy at address %d\n", phydev->addr);
+	ret = fec_probe(bis, -1, IMX_FEC_BASE, bus, phydev);
+	if (ret)
+		goto free_phydev;
+
+	return 0;
+
+free_phydev:
+	free(phydev);
+free_bus:
+	free(bus);
+	return ret;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+static void setup_usb(void)
+{
+	SETUP_IOMUX_PADS(usb_pads);
+	
+	gpio_direction_output(USB_OTG_VBUS, 0);
+	gpio_direction_output(USB_H1_VBUS, 0);
+
+	imx_iomux_set_gpr_register(1, 13, 1, 0);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	switch(port) {
+	case 1:
+		gpio_direction_output(USB_H1_VBUS, 1);
+		break;
+	}
+
+	return 0;
+}
+
+int board_usb_phy_mode(int port)
+{
+	switch(port) {
+	case 0:
+		return USB_INIT_DEVICE;
+	}
+	
+	return usb_phy_mode(port);
+}
+#endif
+
+static void setup_display_early(void)
+{
+	/* Setup backlight */
+	SETUP_IOMUX_PADS(backlight_pads);
+
+	/* Turn off backlight until display is ready */
+	gpio_direction_output(BACKLIGHT_EN , 0);
+}
+
+int board_early_init_f(void)
+{
+	dart_mx6_early_init_f();
+
+	setup_display_early();
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+	return dart_mx6_board_init();
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	env_set("board_name", "DT6CUSTOMBOARD");
+#endif
+
+	return dart_mx6_late_init();
+}
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+void board_init_f(ulong dummy)
+{
+	dart_mx6_init_f(dummy);
+}
+#endif
diff --git a/configs/dt6customboard_defconfig b/configs/dt6customboard_defconfig
new file mode 100644
index 0000000..76e846e
--- /dev/null
+++ b/configs/dt6customboard_defconfig
@@ -0,0 +1,47 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_TARGET_DT6CUSTOMBOARD=y
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_LIBDISK_SUPPORT=y
+CONFIG_SPL_WATCHDOG_SUPPORT=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/mach-imx/spl_sd.cfg,SPL,MX6QDL"
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_DEFAULT_DEVICE_TREE="imx6q-var-dt6customboard"
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_SPL=y
+CONFIG_SPL_EXT_SUPPORT=y
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_IMLS=n
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_NETDEVICES=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_MICREL=y
+CONFIG_PHY_MICREL_KSZ90X1=y
+CONFIG_USB=y
+CONFIG_USB_STORAGE=y
+CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP=y
+CONFIG_USB_ETHER=y
+CONFIG_USB_ETH_CDC=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_OF_LIBFDT=y
diff --git a/include/configs/dt6customboard.h b/include/configs/dt6customboard.h
new file mode 100644
index 0000000..b189b6a
--- /dev/null
+++ b/include/configs/dt6customboard.h
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __DT6_CUSTOMBOARD_CONFIG_H
+#define __DT6_CUSTOMBOARD_CONFIG_H
+
+#include <config_distro_defaults.h>
+#include "mx6_common.h"
+
+#include "imx6_spl.h"
+
+#define CONFIG_IMX_THERMAL
+
+#define CONFIG_SYS_MALLOC_LEN		(10 * SZ_1M)
+#define CONFIG_MXC_UART
+
+/* MMC Configs */
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC3_BASE_ADDR
+
+/* Ethernet Configuration */
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_FEC_MXC_PHYADDR		7
+#define CONFIG_PHY_MICREL_KSZ9031
+
+/* USB */
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_MXC_USB_PORTSC		(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS		0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT	2
+#define CONFIG_PREBOOT \
+	"setenv stdin  serial; " \
+	"setenv stdout serial; " \
+	"setenv stderr serial; "
+
+/* I2C Configs */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C2         /* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE100
+#define CONFIG_POWER_PFUZE100_I2C_ADDR	0x08
+
+/* Display */
+#define CONFIG_IMX_HDMI
+
+/* Command definition */
+
+#define CONFIG_MXC_UART_BASE	UART1_BASE
+#define CONSOLE_DEV	"ttymxc0"
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_SYS_MMC_ENV_DEV		0	/* SDHC2 */
+
+#define CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"fdtfile=imx6q-var-dt6customboard.dtb\0" \
+	"fdt_addr_r=0x18000000\0" \
+	"fdt_addr=0x18000000\0" \
+	"kernel_addr_r=" __stringify(CONFIG_LOADADDR) "\0"  \
+	"pxefile_addr_r=" __stringify(CONFIG_LOADADDR) "\0" \
+	"scriptaddr=" __stringify(CONFIG_LOADADDR) "\0" \
+	"ramdisk_addr_r=0x13000000\0" \
+	"ramdiskaddr=0x13000000\0" \
+	"initrd_addr=0x13000000\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_high=0xffffffff\0" \
+	"ip_dyn=yes\0" \
+	"console=" CONSOLE_DEV ",115200\0" \
+	"bootm_size=0x10000000\0" \
+	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
+	"finduuid=part uuid mmc 0:1 uuid\0" \
+	BOOTENV
+
+#define CONFIG_BOOTCOMMAND \
+	"run finduuid; " \
+	"run distro_bootcmd"
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(MMC, mmc, 0) \
+	func(USB, usb, 0) \
+	func(PXE, pxe, na) \
+	func(DHCP, dhcp, na)
+
+#include <config_distro_bootcmd.h>
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS
+#endif /* CONFIG_SPL_BUILD */
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define CONFIG_SYS_SDRAM_BASE          MMDC0_ARB_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* Environment organization */
+#define CONFIG_ENV_SIZE			(8 * 1024)
+#define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
+
+#endif                         /* __DT6_CUSTOMBOARD_CONFIG_H */
-- 
2.7.4

